"""
计算可执行的cdc分数
"""
import os
import json
import math
import re
import sys

#Rule2
def is_code_valid(code):
    """
    Determine if the code is valid.
    """
    try:
        compile(code, '<string>', 'exec')
        return True
    except:
        return False

#Rule3
def is_correct_parameter_count(function_name, correct_code, test_code):
    """
    Check if the number of parameters is consistent.
    """
    pattern = rf'{function_name}\((.*?)\)'
    correct_match = re.search(pattern, correct_code)

    if correct_match:
        correct_params = correct_match.group(1).strip()
        correct_param_list = [p.strip() for p in correct_params.split(',') if p.strip()]
        expected_count = len(correct_param_list)
    else:
        expected_count = 0


    test_match = re.search(pattern, test_code)

    if test_match:
        test_params = test_match.group(1).strip()
        test_param_list = [p.strip() for p in test_params.split(',') if p.strip()]
        return len(test_param_list) == expected_count
    else:

        return expected_count == 0 and function_name in test_code


#Rule5
def check_keyword_parameters(function_name, correct_code, test_code):
    """
    Determine if keyword arguments are correctly used.
    """
    pattern = rf'{function_name}\((.*?)\)'
    correct_match = re.search(pattern, correct_code)

    if correct_match:
        correct_params = correct_match.group(1).strip()
        correct_param_list = [p.strip() for p in correct_params.split(',') if p.strip()]

        test_match = re.search(pattern, test_code)

        if test_match:
            test_params = test_match.group(1).strip()
            test_param_list = [p.strip() for p in test_params.split(',') if p.strip()]

            for correct_param in correct_param_list:
                if '=' in correct_param:
                    param_name = correct_param.split('=')[0].strip()
                    if not any(param_name in test_param and '=' in test_param for test_param in test_param_list):
                        return False

            return True

    return False

#Rule4
def with_correct(answer_code:str, model_output:str)->bool:
    """
    When the ground truth involves a with statement,
    determine whether the code generated by the model uses a with statement.
    """
    if not answer_code.startswith('with') and not model_output.startswith('with'):
        return True
    elif answer_code.startswith('with') and model_output.startswith('with'):
        return True
    else:
        return False

def compute_line_score_k(answer:str, model_output:list, k:int, model_filled_code, core_line):

    c = 0
    n = len(model_output)
    for index, code in enumerate(model_output):
        # if re.search(rf'\b{re.escape(answer)}\b', code) and is_code_valid(model_filled_code[str(index + 1)]) == True:#line

        if re.search(rf'\b{re.escape(answer)}\b', code) and is_code_valid(model_filled_code[str(index + 1)]) and is_correct_parameter_count(answer, core_line, code) and with_correct(core_line, code) and check_keyword_parameters(answer, core_line, code):#line
        #     print(f"字符串匹配通过但编译不通过的行：\n"
        #           f"core_token:\t{answer}\n"
        #           f"core_line:\t{core_line}\n"
        #           f"model_output:\t{code}")
        #     print("=====================================")
            c += 1
    if n-c < k:
        return 1.0

    score = 1 - (math.comb(n - c, k))/(math.comb(n, k))

    return score


def compute_block_score_k(answer: str, model_output: list, k: int, core_line_in_core_block, core_line_in_output_clear):
    # 初始化每个条件的失败计数器
    failure_counts = [0, 0, 0, 0, 0]  # 对应5个条件的失败次数

    c = 0
    n = len(model_output)

    if n == 0:
        return 0, failure_counts, 0  # 返回 0 分，以及初始化的计数值

    for index, code in enumerate(model_output):
        # 检查每个条件并记录失败
        cond1 = re.search(rf'\b{re.escape(answer)}\b', code)
        cond2 = is_code_valid(code)
        cond3 = is_correct_parameter_count(answer, core_line_in_core_block, core_line_in_output_clear[index])
        cond4 = with_correct(core_line_in_core_block, core_line_in_output_clear[index])
        cond5 = check_keyword_parameters(answer, core_line_in_core_block, core_line_in_output_clear[index])

        # 统计未通过的条件
        if not cond1:
            failure_counts[0] += 1
        if not cond2:
            failure_counts[1] += 1
        if not cond3:
            failure_counts[2] += 1
        if not cond4:
            failure_counts[3] += 1
        if not cond5:
            failure_counts[4] += 1

        # 如果所有条件都满足，增加正确计数
        if cond1 and cond2 and cond3 and cond4 and cond5:
            c += 1

    # 计算总失败次数（即 n - c）
    total_failures = n - c
    if n < k:
        # 如果生成的答案总数少于k，我们无法从中选出k个，
        # 这种情况下，如果失败数也少于k，可以认为是满分。
        # 但如果 total_failures >= k (这在 n<k 时不可能发生), 则需要处理
        if total_failures < k:
            return 1, failure_counts, total_failures
        else:  # 逻辑上走不到这里，但是为了代码健壮性
            return 0, failure_counts, total_failures

        # 只有当 n >= k 时，组合数计算才是安全的
    if total_failures < k:
        return 1, failure_counts, total_failures

    score = 1 - (math.comb(total_failures, k)) / (math.comb(n, k))
    return score, failure_counts, total_failures

#Rule 1
# def compute_block_pass_k(answer:str, model_output:list, k:int):
#
#     c = 0
#     n = len(model_output)
#     for index, code in enumerate(model_output):
#         if re.search(rf'\b{re.escape(answer)}\b', code):#block
#         #     try:
#         #         print(f"data id:\t{data_id}\n")
#         #         print(f"字符串匹配通过但编译不通过的行：\n"
#         #               f"pass rate:\t{test_results[str(index + 1)]['pass_rate']}\n"
#         #               f"core_token:\t{answer}\n"
#         #               f"core_line:\t{core_line_in_core_block}\n"
#         #               f"model_output:\t{core_line_in_output_clear[index]}")
#         #         print("=====================================")
#         #     except:
#         #         pass
#             c += 1
#     if n-c < k:
#         return 1.0
#
#     score = 1 - (math.comb(n - c, k))/(math.comb(n, k))
#
#     return score
#Rule 1
def compute_block_pass_k(answer:str, model_output:list, k:int):
    c = 0
    n = len(model_output)

    # 在函数开头添加同样的检查
    if n == 0:
        return 0.0 # 如果没有输出，直接返回0分

    for index, code in enumerate(model_output):
        if re.search(rf'\b{re.escape(answer)}\b', code):#block
            c += 1
    if n-c < k:
        return 1.0

    score = 1 - (math.comb(n - c, k))/(math.comb(n, k))

    return score

if __name__ =="__main__":

    k = 1   #em@k
    task = "block"

    model = 'Llama3-70B'

    model_name = sys.argv[1]
    ft_type = sys.argv[2]
    edit_order_1 = sys.argv[3]  # 原始 JSONL 文件路径
    edit_order_2 = sys.argv[4]  # 原始 JSONL 文件路径

    if "/" in model_name:
        model_file_name = model_name.split("/")[-1]
    else:
        model_file_name = model_name

    output_dir = f"../../datasets/code_migration/samples/outputs/{ft_type}/{model_file_name}/res"
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    input_json_file = f"../../datasets/code_migration/samples/outputs/{ft_type}/{model_file_name}/res/{edit_order_1}_to_{edit_order_2}.json"

    with open(input_json_file, 'r', encoding='utf-8')as fr:
        lodict = json.load(fr)
    data_list = lodict['data']

    if task == 'line':
        score_list = []
        for data in data_list:
            model_output_list = data['model_output_clear']  # change block or token or line
            temp_list = []
            for o in model_output_list:
                temp_out = o.replace('```python', '')
                temp_out = temp_out.replace('```', '')
                temp_list.append(temp_out)
            model_output = temp_list
            answer = data['core_token']
            model_filled_code = data['model_filled_code']
            core_line = data['core_line']
            score_list.append(compute_line_score_k(answer, model_output, k, model_filled_code, core_line))

        final_score = sum(score_list)/len(score_list)
        print(f"{model}的{task}的cdc@{k}为\t{final_score}")

    elif task == 'block':
        score_list = []
        score_list_3 = []
        failure_counts_list =[]
        total_failures_list = []
        score_p_list = []
        rules = [0,0,0,0,0,0]
        for data in data_list:
            if "old" in sys.argv[1]:
                answer = data['new_name']
            elif "new" in sys.argv[1]:
                answer = data['old_name']
            elif "minor" or "major" in sys.argv[1]:
                answer = data['new_name']
            else:
                answer = data['answer']

            model_output_list = data['model_output_clear'] # change block or token or line

            temp_list = []
            for o in model_output_list:
                temp_out = o.replace('```python', '')
                temp_out = temp_out.replace('```', '')
                temp_list.append(temp_out)
            model_output = temp_list
            core_line_in_core_block = data['core_line_in_core_block']
            core_line_in_output_clear = data['core_line_in_output_clear']
            cdc_1,failure_counts,total_failures = compute_block_score_k(answer, model_output, k, core_line_in_core_block, core_line_in_output_clear)
            score_list.append(cdc_1)
            # compute cdc@3
            cdc_3,failure_counts_,total_failures_ = compute_block_score_k(answer, model_output, 3, core_line_in_core_block, core_line_in_output_clear)
            score_list_3.append(cdc_3)
            score_p_list.append(compute_block_pass_k(answer, model_output, k))
            failure_counts_list.append(failure_counts)
            total_failures_list.append(total_failures)

        print(len([n for n in score_list if n==1.0]))
        final_score = sum(score_list) / len(score_list)
        pass_k_socre = sum(score_p_list) / len(score_list)
        final_score_3 = sum(score_list_3) / len(score_list_3)
        failure_dis = [sum(col) / len(col) for col in zip(*failure_counts_list)]

        # ===== 添加简化的输出格式供shell脚本解析 =====
        print(f"SHELL_PARSE:{final_score},{final_score_3},{pass_k_socre}")
        # ===== 简化输出结束 =====

        # 保留原有输出以便调试
        print(f"{model_name}的{task}的cdc@{k}为\t{final_score}")
        print(f"{model_name}的{task}的cdc@{3}为\t{final_score_3}")
        print(f"{model_name}的{task}的em@{k}为\t{pass_k_socre}")
        print(failure_dis)
        print(sum(total_failures_list) / len(total_failures_list))