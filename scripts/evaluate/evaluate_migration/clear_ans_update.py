"""
Clear the<start>and<end>generated by the model in inference
"""

import json
import os
import sys
import re

# model_name = 'Llama-3-70b-chat-hf'

# result_path = f'/Users/qingyuanzii/Desktop/Versi-Code-Gen/VerisiCode-RAG/Generation/output/library_source_code/withoutRAG/line/meta-llama/Llama-3-70b-chat-hf/library_source_code_line.json' #改 token,line,block
# result_path = sys.argv[1]
# sample_num = int(sys.argv[2])
# result_path = "/Users/qingyuanzii/Desktop/Versi-Code-Gen/VerisiCode-RAG/Generation/together_ai/tmp/meta-llama/Llama-3-70b-chat-hf/stackoverflow_block.json"

import json

model_name = sys.argv[1]
ft_type = sys.argv[2]
edit_order_1 = sys.argv[3]  # 原始 JSONL 文件路径
edit_order_2 = sys.argv[4]  # 原始 JSONL 文件路径

def rep_clean(output):
    return output.replace("```python\n", "").replace("\n```", ""). \
                replace("```\n", "").replace("```\npython", "").replace("python\n", "").replace("```", "")


def extract_all_code_blocks(text: str) -> list[str]:
    """
    使用正则表达式从文本中提取所有被 <start> 和 <end> 包围的代码块。
    返回一个包含所有匹配项的列表。
    """
    pattern = r"<start>(.*?)<end>"
    matches = re.findall(pattern, text, re.DOTALL)

    # 清理每个代码块前后的空白字符和换行符
    cleaned_matches = [match.strip() for match in matches]

    # 如果没有找到任何匹配项，返回一个空列表
    return cleaned_matches

if "/" in model_name:
    model_file_name = model_name.split("/")[-1]
else:
    model_file_name = model_name

# if "new" in sys.argv[2] or "old" in sys.argv[2]:
#     input_file = f"../../datasets/code_migration/samples/outputs/{model_file_name}/code_migration_exe_{edit_order_1}_to_{edit_order_2}.json"
# else:
#     input_file = f"../../datasets/code_migration/samples/outputs/{model_file_name}/{edit_order_1}_to_{edit_order_2}.json"

input_file = f"../../datasets/code_migration/samples/outputs/{ft_type}/{model_file_name}/{edit_order_1}_to_{edit_order_2}.json"

key_to_check = 'model_output'  # 需要检查的键

clear_list = []
with open(input_file, 'r', encoding='utf-8') as infile:
    load_dic = json.load(infile)
    for line in load_dic["data"]:
        if key_to_check in line.keys():  # 检查字典中是否存在指定的键
           clear_list.append(line)

clear_dict = {"data":clear_list}
sample_num = len(clear_list)

output_dir = f"../../datasets/code_migration/samples/outputs/{ft_type}/{model_file_name}/res/"
if not os.path.exists(output_dir):
    os.mkdir(output_dir)

result_path = f"../../datasets/code_migration/samples/outputs/{ft_type}/{model_file_name}/res/{edit_order_1}_to_{edit_order_2}.json"

with open(result_path,"w",encoding='utf-8') as f:
    json.dump(clear_dict, f, indent=4, ensure_ascii=False)


# def clear_again(content):
#     if "<start/>" and "</end>" in content:
#         start_index = output.find("<start/>") + len("<start/>")
#         end_index = output.find("</end>")
#         content = output[start_index:end_index].replace('```python', '').replace('```', '')
#     elif "<start/>" in output and "</end>" not in output:
#             start_index = output.find("<start/>") + len("<start/>")
#             content = output[start_index:].replace('```python', '').replace('```', '')
#
#     # The model output onlyt contains "<end>"
#     elif "<start/>" not in output and "</end>" in output:
#         end_index = output.find("</end>")
#         content = output[0:end_index].replace('```python', '').replace('```', '')
#
#     else:
#         content = output.replace("```python\n", "").replace("\n```", ""). \
#             replace("```\n", "").replace("```\npython", "").replace("python\n", "").replace("```", "")
#     return content

with open(result_path, 'r', encoding='utf-8')as fr:
    lodict = json.load(fr)
data_dict = lodict
data_list = data_dict['data']

for idx,data in enumerate(data_list):
    temp_list = []
    try:
        model_output_list = eval(data['model_output'])  #改
        # model_output_list = data['model_output']  #改
    except:
        try:

            model_output_list = extract_all_code_blocks(data['model_output'])
        except:
            print(idx)

    for output in model_output_list:
        if output is None:
            output = ""
            # 确保 output 是字符串类型
        if not isinstance(output, str):
            output = str(output)


        if "<start>" in output and "<end>" in output:
            start_index = output.find("<start>") + len("<start>")
            end_index = output.find("<end>")
            content = output[start_index:end_index]


        # The model output onlyt contains "<start>"
        elif "<start>" in output and "<end>" not in output:
            start_index = output.find("<start>") + len("<start>")
            content = output[start_index:]

        # The model output onlyt contains "<end>"
        elif "<start>" not in output and "<end>" in output:
            end_index = output.find("<end>")
            content = output[0:end_index]

        else:
            content = output
        _content = rep_clean(content)

        temp_list.append(_content)

    data['model_output_clear'] = temp_list   #change token,line,block

with open(result_path, 'w', encoding='utf-8')as fw:
    json.dump(data_dict, fw, indent=4, ensure_ascii=False)
print(len(data_dict["data"]))